# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tn-XXiutwhWgqrsrsEH0xZGdHFkAJGh5
"""

# app.py

import streamlit as st
import random
import matplotlib.pyplot as plt

streamlit run app.py

# ------------------------------
# PAGE CONFIGURATION
# ------------------------------
st.set_page_config(page_title="Genetic Algorithm Bit Pattern Optimizer", layout="centered")

# ------------------------------
# HEADER AND STUDENT DETAILS
# ------------------------------
st.markdown("""
# **Name:** AHMAD DHANI BIN NORMANN ARBAQ
### **Student ID:** SD23051
### **Section:** 02G
---
## üß¨ Genetic Algorithm Bit Pattern Optimizer
This Streamlit application demonstrates how a **Genetic Algorithm (GA)** evolves binary strings to
maximize fitness by approaching a target number of ones in each chromosome.
""")

# ------------------------------
# SIDEBAR USER INPUTS
# ------------------------------
st.sidebar.header("‚öôÔ∏è Algorithm Parameters")
POP_SIZE = st.sidebar.slider("Population Size", 100, 500, 300)
GEN_LENGTH = st.sidebar.slider("Chromosome Length", 20, 100, 80)
TARGET_ONES = st.sidebar.slider("Target Number of Ones", 10, GEN_LENGTH, 50)
GENERATIONS = st.sidebar.slider("Number of Generations", 10, 200, 50)
MUTATION_RATE = st.sidebar.slider("Mutation Rate", 0.001, 0.1, 0.01)

# ------------------------------
# GENETIC ALGORITHM FUNCTIONS
# ------------------------------
def fitness(individual):
    ones = sum(individual)
    return GEN_LENGTH - abs(ones - TARGET_ONES)

def select_parents(population):
    return random.choices(population, weights=[fitness(p) for p in population], k=2)

def crossover(p1, p2):
    point = random.randint(1, GEN_LENGTH - 1)
    return p1[:point] + p2[point:], p2[:point] + p1[point:]

def mutate(individual):
    return [1 - bit if random.random() < MUTATION_RATE else bit for bit in individual]

def create_individual():
    return [random.randint(0, 1) for _ in range(GEN_LENGTH)]

# ------------------------------
# RUN GENETIC ALGORITHM
# ------------------------------
if st.button("üöÄ Run Genetic Algorithm"):
    population = [create_individual() for _ in range(POP_SIZE)]
    best_fitness_values = []

    for generation in range(GENERATIONS):
        population.sort(key=fitness, reverse=True)
        best = fitness(population[0])
        best_fitness_values.append(best)

        new_population = population[:20]  # Elitism
        while len(new_population) < POP_SIZE:
            p1, p2 = select_parents(population)
            c1, c2 = crossover(p1, p2)
            new_population.extend([mutate(c1), mutate(c2)])
        population = new_population[:POP_SIZE]

    # Results
    best_individual = max(population, key=fitness)
    best_score = fitness(best_individual)

    st.success(f"‚úÖ Optimal Fitness Achieved: **{best_score}**")
    st.text(f"Best Individual (Chromosome): {''.join(map(str, best_individual))}")

    # ------------------------------
    # VISUALIZATION
    # ------------------------------
    fig, ax = plt.subplots()
    ax.plot(range(1, GENERATIONS + 1), best_fitness_values, linewidth=2)
    ax.set_title("Fitness Progress Over Generations")
    ax.set_xlabel("Generation")
    ax.set_ylabel("Best Fitness Value")
    ax.grid(True)
    st.pyplot(fig)

    # Explanation
    st.subheader("üìà Interpretation")
    st.write(f"""
    The algorithm evolves a population of **{POP_SIZE} chromosomes**, each with **{GEN_LENGTH} bits**,
    aiming to reach exactly **{TARGET_ONES} ones**.
    Across **{GENERATIONS} generations**, the genetic algorithm uses **selection, crossover, and mutation**
    to maximize the fitness score.
    A mutation rate of **{MUTATION_RATE:.3f}** maintains diversity and prevents stagnation.
    """)

# ------------------------------
# FOOTER
# ------------------------------
st.caption("Developed for BSD3513 ‚Äì Introduction to Artificial Intelligence | Guided by Dr. Ku Muhammad Na‚Äôim Ku Khalif")